/**********************************************************************************************************************
 * \file Overlay_Test.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Overlay_Test.h"
#include <string.h>

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define RESULT_OK                                       0
#define RESULT_ERR                                      0xFF

#define BUF_SIZE                                        32                                 /* Byte                   */
#define BUF_SIZE_MAX                                    2048                               /* Byte                   */

#define ledOn(LED)                                      IfxPort_setPinLow(LED)
#define ledOff(LED)                                     IfxPort_setPinHigh(LED)
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Buffer consists of new contents of PFlash */
 uint8 BeforeOverlayEnable[BUF_SIZE] = {0};

 /* Buffer consists of new contents of SRAM */
 uint8 AfterOverlayEnable[BUF_SIZE] = {0};

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/* Global Variables used in Test 1 */
/* CPU0 PFLASH  */
const volatile uint8 TEST_1_BUF_FLASH[BUF_SIZE] __attribute__((used)) __attribute__((section(".rodata_cpu0"))) __attribute__ ((aligned(1*32)))=
 {      32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
 };

/* CPU0 DSPR */
 const volatile uint8 TEST_1_BUF_DSPR[BUF_SIZE] __attribute__((used)) __attribute__ ((section(".data_cpu0"))) __attribute__ ((aligned(1*32))) = {0xB, 0xA, 0x5, 0xE, 0xB, 0xA, 0x1, 0x1};

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
/* To verify access the overlaid memory
 * Check the Overlay value stored in RAM (Redirect Memory) instead of Flash (Target Memory)
 */
 uint8 Test_MemoryValidation(uint8* target, uint8* redirect, uint32 size);
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
 void Test_init(void)
 {
     /* Initialization of the LED used in this example */
     IfxPort_setPinModeOutput(LED_ERROR, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
     IfxPort_setPinModeOutput(LED_SUCCESS, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

     /* Switch OFF the LED (low-level active) */
     ledOff(LED_ERROR);
     ledOff(LED_SUCCESS);
 }

 /* Test1 has been provided in this code example.
  * To ensure that the redirection of memory accesses is accurately configured.
  *
  * Test_1   The reaction for Test is ( LED Success ON)
  */

 /* Test 1
  * Implementing Overlay with Registers Configuration (without using iLLD)
  * For 1 Block (32 Byte address range) where the Target Memory is any PFLASH bank (non-cached)
  * The Redirection Memory shall be DSPR.
  */
 void Test_1(void)
 {

     uint8* overlayData = (uint8*) TEST_1_BUF_DSPR;

     uint8 i;

     /* Prevent DAMData from being optimized out */
     overlayData[0] = 0xB;

     /* Configure Overlay Block */
     /* Set up the Redirected Address Base Register (RABR)  */
     /* Configure RABR fields */
     CPU0_RABR0.U = (0x1 << 31)|                                  /* Configure OVEN (Overlay Enabled) */
                    (0x0 << 24)|                            /* Configure OMEM (Overlay Memory Select) */
                    ((uint32)(&TEST_1_BUF_DSPR[0]));        /* Configure OBASE (Overlay Base Address) */

     /* Set up the Overlay Target Address Register (OTAR) */
     CPU0_OTAR0.U =  (uint32)&TEST_1_BUF_FLASH[0];

     /* Set up the Overlay Mask Register (OMASK)- 32 byte block size (see user manual)- change TC4x compare to TC3XX*/
     CPU0_OMASK0.U = (0x1FFFF << 5);

     /* Enable the overlay Block in the Overlay Range Select Register (OSEL) */
     CPU0_OSEL.B.SHOVEN00 = 1;

     /* Write new contents of PFlash into Buffer BeforeOverlayEnable */
     for(i = 0; i < sizeof(BeforeOverlayEnable); i++)
     {
         BeforeOverlayEnable[i] = TEST_1_BUF_FLASH[i];
     }

     /* Overlay enabled on CPU0 */
     SCU_OVCENABLE.B.OVEN0 = 0x1;

     /* Turn on Overlay memory and enable block   */
     SCU_OVCCON.U = ( 0x1 << 0  /*CSEL0*/ )|
                    ( 0x0 << 1  /*CSEL1*/ )|
                    ( 0x0 << 2  /*CSEL2*/ )|
                    ( 0x0 << 3  /*CSEL3*/ )|
                    ( 0x0 << 4  /*CSEL4*/ )|
                    ( 0x0 << 5  /*CSEL5*/ )|
                    ( 0x1 << 16 /*OVSTRT*/)|
                    ( 0x0 << 17 /*OVSTP*/ )|
                    ( 0x1 << 18 /*DCINVAL*/)| /* Data Cache Invalidate (may be needed) */
                    ( 0x1 << 24 /*OVCONF*/ )|
                    ( 0x0 << 25 /*POVCONF*/); /* Enable write to OVCCON */

     __dsync();

     /* Prevent DAMData from being optimized out */
     overlayData[0] = 0xB;
     overlayData[1] = 0xC;

     /* Write new contents of SRAM into Buffer AfterOverlayEnable */
     for(i=0;i<sizeof(AfterOverlayEnable);i++)
     {
         AfterOverlayEnable[i] = TEST_1_BUF_FLASH[i];
     }

     /* Verify, Before and After must not be same */
     Test_MemoryValidation(BeforeOverlayEnable, AfterOverlayEnable, sizeof(BeforeOverlayEnable));

     /* Disable Overlay */
     SCU_OVCCON.U = ( 0x1 << 0  /*CSEL0*/ )|
                    ( 0x0 << 1  /*CSEL1*/ )|
                    ( 0x0 << 2  /*CSEL2*/ )|
                    ( 0x0 << 3  /*CSEL3*/ )|
                    ( 0x0 << 4  /*CSEL4*/ )|
                    ( 0x0 << 5  /*CSEL5*/ )|
                    ( 0x0 << 16 /*OVSTRT*/)|
                    ( 0x1 << 17 /*OVSTP*/ )|
                    ( 0x1 << 18 /*DCINVAL*/)| /* Data Cache Invalidate (may be needed) */
                    ( 0x1 << 24 /*OVCONF*/ )|
                    ( 0x0 << 25 /*POVCONF*/); /* Enable write to OVCCON */

         SCU_OVCENABLE.B.OVEN0 = 0x0;
    }

 /* Compare the new contents of the PFlash, stored in the BeforeOverlayEnable with RAM.
  * If the value written in "BeforeOverlayEnable" and "AfterOverlayEnable" will be equal then the error would be happened.
    else, LED_SUCCESS (LED2) will be toggling, which indicates overlay functionality. */
 uint8 Test_MemoryValidation(uint8* target, uint8* redirect, uint32 size)
 {
     uint8* pTarget;
     uint8* pRedirect;
     uint8  result = RESULT_ERR;

     pTarget = target;

     /* Verify Values of Target Address and Redirect Address */

     pRedirect = redirect;

     for (uint32 i = 0; i < size; i++)
     {
         /* read from the redirect and target address and compare. */
         if (*pTarget++ != *pRedirect++)
         {

             result = RESULT_OK;
             break;
         }
     }
     if (result == RESULT_OK)
     {
         /* Enable LED Success */
         ledOn(LED_SUCCESS);
         return 1;
     }
     else
     {
         /* Enable LED Error */
         ledOn(LED_ERROR);
         return 0;
     }
 }
