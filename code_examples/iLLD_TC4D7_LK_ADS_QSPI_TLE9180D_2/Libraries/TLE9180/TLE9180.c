/*
 * \file TLE9180.c
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#include "Bsp.h"
#include "TLE9180.h"

#define IFX_TLE9180_SPI_STUP_COMMANDS_SIZE (sizeof(IfxTLE9180_startupConfig)/sizeof(IfxTLE9180_SpiTx))
#define IFX_TLE9180_SPI_READ_COMMANDS_SIZE (sizeof(IfxTLE9180_readCommands)/sizeof(IfxTLE9180_SpiTx))

static const IfxTLE9180_SpiTx IfxTLE9180_startupConfig[]=
{
    { .B.C=1, .B.ADDRESS= 0x01, .B.DATA= 0x81, .B.CRC= 4},   /**< \brief Config General Configuration 1 */
    { .B.C=1, .B.ADDRESS= 0x02, .B.DATA= 0x0F, .B.CRC= 0},   /**< \brief Config General Configuration 2 */
    { .B.C=1, .B.ADDRESS= 0x06, .B.DATA= 0x70, .B.CRC= 6},   /**< \brief Config VDHP Over & Under voltage Thresholds */
    { .B.C=1, .B.ADDRESS= 0x07, .B.DATA= 0x9A, .B.CRC= 6},   /**< \brief Config VDHP Over & Under voltage Thresholds */
    { .B.C=1, .B.ADDRESS= 0x08, .B.DATA= 0x32, .B.CRC= 1},   /**< \brief Config Charge Pump/High-side Buffer Failure Modes */
    { .B.C=1, .B.ADDRESS= 0x0A, .B.DATA= 0x2A, .B.CRC= 3},   /**< \brief Config Vs & VDHP & VCC Undervoltage Failure Modes */
    { .B.C=1, .B.ADDRESS= 0x0B, .B.DATA= 0x4A, .B.CRC= 3},   /**< \brief Config Vs & VDHP & VCC Overvoltage Failure Modes */
    { .B.C=1, .B.ADDRESS= 0x13, .B.DATA= 0x2A, .B.CRC= 5},   /**< \brief Config Overcurrent Failure Modes */
    { .B.C=1, .B.ADDRESS= 0x00, .B.DATA= 0xAC, .B.CRC= 2},   /**< \brief Config Configuration Signature */
    { .B.C=1, .B.ADDRESS= 0x20, .B.DATA= 0x44, .B.CRC= 3},   /**< \brief Config Current Sense Amplifier 1&2 - Gain 1 */
    { .B.C=1, .B.ADDRESS= 0x21, .B.DATA= 0x44, .B.CRC= 7},   /**< \brief Config Current Sense Amplifier 1&2 - Gain 2 */
    { .B.C=1, .B.ADDRESS= 0x22, .B.DATA= 0x44, .B.CRC= 0},   /**< \brief Config Current Sense Amplifier 3 - Gain 1&2 */
    { .B.C=1, .B.ADDRESS= 0x23, .B.DATA= 0x9F, .B.CRC= 0}    /**< \brief Config Current Sense Amplifier Zero Current Offset */
};



const IfxTLE9180_SpiTx IfxTLE9180_readCommands[]=
{
    { .B.C=0, .B.ADDRESS= 0x25, .B.DATA= 0x00, .B.CRC= 7},   /**< \brief Read Short Circuit Detection Threshold LS1 */
    { .B.C=0, .B.ADDRESS= 0x26, .B.DATA= 0x00, .B.CRC= 0},   /**< \brief Read Short Circuit Detection Threshold LS2 */
    { .B.C=0, .B.ADDRESS= 0x27, .B.DATA= 0x00, .B.CRC= 4},   /**< \brief Read Short Circuit Detection Threshold LS3 */
    { .B.C=0, .B.ADDRESS= 0x28, .B.DATA= 0x00, .B.CRC= 2},   /**< \brief Read Short Circuit Detection Threshold HS1 */
    { .B.C=0, .B.ADDRESS= 0x29, .B.DATA= 0x00, .B.CRC= 6},   /**< \brief Read Short Circuit Detection Threshold HS2 */
    { .B.C=0, .B.ADDRESS= 0x2A, .B.DATA= 0x00, .B.CRC= 1},   /**< \brief Read Short Circuit Detection Threshold HS3 */
    { .B.C=0, .B.ADDRESS= 0x2B, .B.DATA= 0x00, .B.CRC= 5},   /**< \brief Read Limp Home Activation status */
    { .B.C=0, .B.ADDRESS= 0x2C, .B.DATA= 0x00, .B.CRC= 4},   /**< \brief Read Shift Phase Voltage Feedback and CSA Gain */
    { .B.C=0, .B.ADDRESS= 0x2D, .B.DATA= 0x00, .B.CRC= 0},   /**< \brief Read Passive Rectification Threshold */
    { .B.C=0, .B.ADDRESS= 0x2E, .B.DATA= 0x00, .B.CRC= 7},   /**< \brief Read Active Rectification Threshold */
    { .B.C=0, .B.ADDRESS= 0x2F, .B.DATA= 0x00, .B.CRC= 3},   /**< \brief Read Rectification Filter Time */
    { .B.C=0, .B.ADDRESS= 0x30, .B.DATA= 0x00, .B.CRC= 0},   /**< \brief Read Rectification Accuracy */
    { .B.C=0, .B.ADDRESS= 0x00, .B.DATA= 0x00, .B.CRC= 4}    /**< \brief Read Configuration Signature */
};

static IfxTLE9180_SpiRx   IfxTLE9180_receiveBuffer[IFX_TLE9180_SPI_BUFFER_SIZE];

/**
 * \brief Initialize the TLE9180 driver/interface.
 *
 * \param handle specifies pointer to the \ref TLE9180 object. Values will be populated by this function
 * \param config specifies pointer to the configuration structure
 *
 * \ingroup mod_tle9180_serial
 */


boolean IfxTLE9180_init(IfxTLE9180 *tle9180, const IfxTLE9180_Config *config)
{
	boolean result = TRUE;
	uint32 index;
    Ifx_TickTime time = getDeadLine(TimeConst_1ms);

    tle9180->size = config->size;
    tle9180->pins= config->pins;
    tle9180->spiIf= config->spiIf;
    tle9180->spiChannel= config->spiChannel;
    tle9180->receiveBuffer= IfxTLE9180_receiveBuffer;

    IfxPort_setPinMode(tle9180->pins.inhibit->port, tle9180->pins.inhibit->pinIndex, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(tle9180->pins.enable->port, tle9180->pins.enable->pinIndex, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(tle9180->pins.safeOff->port, tle9180->pins.safeOff->pinIndex, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(tle9180->pins.error->port, tle9180->pins.error->pinIndex, IfxPort_Mode_inputNoPullDevice);

    /* init buffer area */
    for(index= 0; index < IFX_TLE9180_SPI_BUFFER_SIZE; index++)
    {
    	tle9180->receiveBuffer[index].U = 0;
    }

    IfxTLE9180_deactivateInhibit(tle9180);
    while(isDeadLine(time) != TRUE);
    time = getDeadLine(TimeConst_1s);
    IfxTLE9180_activateInhibit(tle9180);

    while(isDeadLine(time) != TRUE);	// Wait
    time = getDeadLine(TimeConst_1ms);
    IfxTLE9180_deactivateInhibit(tle9180);

    while(isDeadLine(time) != TRUE);	// Wait
    IfxTLE9180_deactivateSafeOff(tle9180);

    return result;
}

boolean IfxTLE9180_loadStartupConfiguration(IfxTLE9180 *tle9180)
{
	boolean result = FALSE;

	while(result!=TRUE)
	{
		result = (tle9180->spiIf.spiExchange(tle9180->spiChannel, (void*)IfxTLE9180_startupConfig, tle9180->receiveBuffer, IFX_TLE9180_SPI_STUP_COMMANDS_SIZE) == 0);
	}

	return(result);
}

/** \brief API to periodically read TLE9180 registers
 * This API shall be called at periodic task each time, this fetches one register value
 * current register that is fetched is indexed with tle9180->readIndex
 */

boolean IfxTLE9180_readRegister(IfxTLE9180 *tle9180)
{
	boolean result;
	uint8 status;

	status= tle9180->spiIf.spiExchange(tle9180->spiChannel,
			(void*)&IfxTLE9180_readCommands[tle9180->readIndex],
			&tle9180->receiveBuffer[IFX_TLE9180_SPI_STUP_COMMANDS_SIZE + 2 + tle9180->readIndex],
			1);
	result= (status == 0)?TRUE:FALSE;

	if(result != FALSE)
	{
		if(++tle9180->readIndex >= IFX_TLE9180_SPI_READ_COMMANDS_SIZE)
		{
			tle9180->readIndex = 0;
		}
	}
	return(result);
}
