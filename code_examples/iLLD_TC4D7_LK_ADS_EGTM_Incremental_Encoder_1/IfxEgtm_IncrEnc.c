/**********************************************************************************************************************
 * \file IfxEgtm_IncrEnc.c
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/


#include "Ifx_Types.h"
#include "IfxEgtm_IncrEnc.h"


/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/


#define PATTERN_A       0x0             /* SPE input pattern: b 00,  */
#define PATTERN_B       0x2             /* SPE input pattern: b 10,  */
#define PATTERN_C       0x3             /* SPE input pattern: b 11,  */
#define PATTERN_D       0x1             /* SPE input pattern: b 01,  */

#define INPUT_0         0x0             /* SPE input 0  */
#define INPUT_1         0x1             /* SPE input 1  */
#define INPUT_2         0x2             /* SPE input 2  */

#define VALID           0x1             /* Pattern valid  */
#define INVALID         0x0             /* Pattern invalid  */

#define TBU_MAX_COUNT   0xFFFFFF                                    /* Max value of SPE_REV_CNT         */
#define PREV_RELOAD     (TBU_MAX_COUNT % driver->resolution) + 1    /* Reload value in case of overflow */


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/* This function EGTM sub-blocks SPE, TIM, interrupts and the pins
 * */
void IfxEgtm_IncrEnc_init(IfxEgtm_IncrEnc* driver, IfxEgtm_IncrEnc_Config *config)
{
    /* Enable EGTM and setup clocks */
    if(!IfxEgtm_isEnabled(&MODULE_EGTM))
    {
        float32 frequency;
        /* Enable EGTM, it is necessary if the EGTM is not initialized earlier */
        IfxEgtm_enable(&MODULE_EGTM);
        frequency = IfxEgtm_Cmu_getModuleFrequency(&MODULE_EGTM);
        /* Set the global clock frequency to the max */
        IfxEgtm_Cmu_setGclkFrequency(&MODULE_EGTM, frequency);
        /* Set the CMU CLK0 */
        IfxEgtm_Cmu_setClkFrequency(&MODULE_EGTM, IfxEgtm_Cmu_Clk_0, frequency);
        /* Enable the CMU clock */
        IfxEgtm_Cmu_enableClocks(&MODULE_EGTM, IFXEGTM_CMU_CLKEN_CLK0);
    }

    /* Update the driver parameters based on the configuration */
    driver->resolution      =  config->resolution * IfxStdIf_Pos_ResolutionFactor_fourFold;
    driver->offset          = config->offset;

    driver->speedUpdate     = config->speedUpdate;
    driver->speedCounter    = 0;
    driver->speedFactor     = (2.0f * IFX_PI) / (config->resolution * IfxStdIf_Pos_ResolutionFactor_fourFold) / ( config->updatePeriod);
    driver->minSpeed        = config->minSpeed;
    driver->maxSpeed        = config->maxSpeed;

    driver->updatePeriod    = config->updatePeriod;
    driver->module          = config->module;

    /* Configure the pins */
    if (config->initPins == TRUE)
    {
        IfxEgtm_PinMap_setTimTin(config->pinA, IfxPort_InputMode_noPullDevice);
        IfxEgtm_PinMap_setTimTin(config->pinB, IfxPort_InputMode_noPullDevice);
        if (config->pinZ != NULL_PTR)
        {
            IfxEgtm_PinMap_setTimTin(config->pinZ, IfxPort_InputMode_noPullDevice);
        }
    }

    /* Enable the TIM channels corresponding to pin A and pin B*/
    IfxEgtm_Tim_ChannelControl timCtrl = {0};
    timCtrl.enable = 1;

    IfxEgtm_Tim_Ch_setControl(&MODULE_EGTM.CLS[config->pinA->tim].TIM.CH[config->pinA->channel], timCtrl);
    IfxEgtm_Tim_Ch_setControl(&MODULE_EGTM.CLS[config->pinB->tim].TIM.CH[config->pinB->channel], timCtrl);

    /* Initialize the patterns for the incremental encoder */
    IfxEgtm_Spe_InputPattern inpPtr[8];
    uint8 index =0;
    inpPtr[0].Signal.valid   = VALID;
    inpPtr[0].Signal.pattern = PATTERN_A;
    inpPtr[1].Signal.valid   = VALID;
    inpPtr[1].Signal.pattern = PATTERN_B;
    inpPtr[2].Signal.valid   = VALID;
    inpPtr[2].Signal.pattern = PATTERN_C;
    inpPtr[3].Signal.valid   = VALID;
    inpPtr[3].Signal.pattern = PATTERN_D;
    inpPtr[4].Signal.valid   = INVALID;
    inpPtr[5].Signal.valid   = INVALID;
    inpPtr[6].Signal.valid   = INVALID;
    inpPtr[7].Signal.valid   = INVALID;

    for(index = 0; index < 8; index++)
    {
        IfxEgtm_Spe_setInputPattern(driver->module, &inpPtr[index], index);
    }

    /* Initialize SPE: STAT (AIP, PIP, SPE_PATTERN_PTR) and STAT2 (SPE_PATTERN_PTR_BWD)
     * according to initial position (NIP) */
    switch(IfxEgtm_Spe_getNewInputPat(driver->module)) /* Check the current value of NIP: New input pattern that was detected */
    {
        case PATTERN_A:
            /* Set initial value of PIP: Previous input pattern that was detected by a regular input pattern change */
            IfxEgtm_Spe_setPreviousInputPat(driver->module, PATTERN_D);
            /* Set initial value of AIP: Actual input pattern that was detected by a regular input pattern change */
            IfxEgtm_Spe_setActualInputPat(driver->module, PATTERN_A);
            break;

        case PATTERN_B:
            IfxEgtm_Spe_setPreviousInputPat(driver->module, PATTERN_A);
            IfxEgtm_Spe_setActualInputPat(driver->module, PATTERN_B);
            break;

        case PATTERN_C:
            IfxEgtm_Spe_setPreviousInputPat(driver->module, PATTERN_B);
            IfxEgtm_Spe_setActualInputPat(driver->module, PATTERN_C);
            break;

        case PATTERN_D:
            IfxEgtm_Spe_setPreviousInputPat(driver->module, PATTERN_C);
            IfxEgtm_Spe_setActualInputPat(driver->module, PATTERN_D);
            break;

        default:
            /* In this case, the value of the registers is guaranteed to be the default value at startup */
            break;
    }

    /* Enable only input 0 and 1 corresponding to pin A and pin B */
    IfxEgtm_Spe_enableInput(driver->module, INPUT_0, TRUE);      /* SPE Input 0 enabled  */
    IfxEgtm_Spe_enableInput(driver->module, INPUT_1, TRUE);      /* SPE Input 1 enabled  */
    IfxEgtm_Spe_enableInput(driver->module, INPUT_2, FALSE);     /* SPE Input 2 disabled */


    IfxEgtm_Spe_selectTimInput(driver->module, config->timSel);  /* SPE TIM input selection     */
    IfxEgtm_Spe_setRevCompare(driver->module, TBU_MAX_COUNT);    /* compare event for overflow  */
    IfxEgtm_Spe_setRevCounter(driver->module, 0);                /* SPE_REV_CNT as 0            */

    /* Configure the interrupt for the EGTM SPE RCMP_IRQ to handle overflow */
    volatile Ifx_SRC_SRCR   *src;
    if (config->speIsrPriority)
    {
        /* Enable RCMP_IRQ and configure pulse-notify mode for SPE  */
        IfxEgtm_Spe_setInterruptMode(driver->module, IfxEgtm_Spe_InterruptMode_pulseNotify);
        IfxEgtm_Spe_enableInterrupt(driver->module, IfxEgtm_Spe_InterruptSignal_rcmp);

        src = &MODULE_SRC.EGTM.SPEIRQ[config->speCluster];
        /* Initialize src node */
        IfxSrc_init(src, config->zeroIsrProvider, config->speIsrPriority, 0);

        /* Enable Src node */
        IfxSrc_enable(src);
    }

    /* Enable SPE module */
    IfxEgtm_Spe_enableModule(driver->module, TRUE);

    /* Configure the EGTM TIM channel and its interrupt related to the pin Z */
    if (config->pinZ != NULL_PTR)
    {
        Ifx_EGTM_CLS_TIM_CH *channel;
        timCtrl.mode = IfxEgtm_Tim_Mode_inputEvent;
        timCtrl.signalLevelControl = TRUE;

        /* Enable TIM channel with TIEM mode for rising edge */
        channel  = IfxEgtm_Tim_getChannel(&MODULE_EGTM.CLS[config->pinA->tim].TIM, config->pinZ->channel);

        /* Enable TIM interrupt for the channel with pulse-notify mode */
        IfxEgtm_Tim_Ch_setNotificationMode(channel, IfxEgtm_IrqMode_pulseNotify);
        IfxEgtm_Tim_Ch_setNotification(channel, IfxEgtm_Tim_IrqType_newVal);
        IfxEgtm_Tim_Ch_setControl(&MODULE_EGTM.CLS[config->pinZ->tim].TIM.CH[config->pinZ->channel], timCtrl);

        if (config->zeroIsrPriority)
        {
            src = &MODULE_SRC.EGTM.TIM[config->pinZ->tim].SR[config->pinZ->channel];
            /* Initialize src node */
            IfxSrc_init(src, config->zeroIsrProvider, config->zeroIsrPriority, 0);

            /* Enable Src node */
            IfxSrc_enable(src);
        }
    }
}

/* This function initializes the configurations to default values
 * */
void IfxEgtm_IncrEnc_initConfig(IfxEgtm_IncrEnc_Config *config, Ifx_EGTM_CLS_SPE *spe)
{
    config->offset             = 0;
    config->resolution         = 0;
    config->updatePeriod       = 0.001f;
    config->minSpeed           = 1.0f / 60.0f * (2 * IFX_PI);                 /* 1 rpm     */
    config->maxSpeed           = 20000.0f / 60.0f * (2 * IFX_PI);             /* 20000 rpm */
    config->pinA               = NULL_PTR;
    config->pinB               = NULL_PTR;
    config->pinZ               = NULL_PTR;
    config->pinMode            = IfxPort_InputMode_noPullDevice;
    config->module             = spe;
    config->zeroIsrPriority    = 0;
    config->zeroIsrProvider    = IfxSrc_Tos_cpu0;
    config->initPins           = TRUE;
}

/* This function is update the rawposition, speed and direction information based
 * on the SPE_REV_CNT and ADIR values
 * */
void IfxEgtm_IncrEnc_update (IfxEgtm_IncrEnc* driver)
{
    sint32 newPosition, diff;
    float32 speed;

    /* Update the direction of rotation */
    driver->direction = IfxEgtm_Spe_getDir(driver->module);

    /* Find the position based on SPE_REV_CNT */
    newPosition = IfxEgtm_Spe_getRevCounter(driver->module);
    newPosition = (newPosition + driver->offset);
    newPosition = newPosition % (driver->resolution);

    /* Update rawposition and increment the counter */
    driver->rawPosition = newPosition;
    driver->speedCounter++;

    /* Update the speed if the counter matches update cycle */
    if(driver->speedCounter >= driver->speedUpdate)
    {
        /* Find absolute difference of previous and current position */
        if (driver->direction == IfxEgtm_Spe_Direction_fwd)
        {
            diff = newPosition - driver->prevPosition;
        }
        else
        {
            diff = driver->prevPosition - newPosition;
        }

        if (diff < 0)
        {
            diff += driver->resolution;
        }

        /* Scale the speed for rad/s */
        speed = (float32)(diff * driver->speedFactor);

        /* Negate speed if the direction if backward */
        speed = driver->direction == IfxEgtm_Spe_Direction_fwd ? speed : -speed;

        /* Update speed and previous position and reset the counter */
        driver->prevPosition = newPosition;
        driver->speed = speed / driver->speedUpdate;
        driver->speedCounter = 0;
    }
}

/* Returns the sensor raw position in ticks.
 * */
sint32 IfxEgtm_IncrEnc_getRawPosition(IfxEgtm_IncrEnc* driver)
{
    return driver->rawPosition;
}

/* Returns the direction of the rotation.
 * */
IfxEgtm_Spe_Direction IfxEgtm_IncrEnc_getDirection(IfxEgtm_IncrEnc* driver)
{
    return driver->direction;
}

/* Returns the speed in rad/s.
 * */
float32 IfxEgtm_IncrEnc_getSpeed(IfxEgtm_IncrEnc* driver)
{
    return driver->speed;
}

/* This function handles the overflow condition of SPE_REV_CNT
 * */
void IfxEgtm_IncrEnc_handleOverflow(IfxEgtm_IncrEnc* driver)
{
    uint32 reloadVal;
    /* Interrupt due to SPE_RCMP_IRQ */
    if(IfxEgtm_Spe_getInterruptStatus(driver->module, IfxEgtm_Spe_InterruptSignal_rcmp))
    {

        /* Read the SPE_REV_CNT */
        reloadVal = IfxEgtm_Spe_getRevCounter(driver->module);
        /* Calculate reload value based on the direction of rotation  */
        if(IfxEgtm_Spe_getDir(driver->module) == IfxStdIf_Pos_Dir_forward)
        {
            reloadVal += PREV_RELOAD;
        }
        else
        {
            reloadVal -= PREV_RELOAD;
        }
        /* Reload the SPE_REV_CNT */
        IfxEgtm_Spe_setRevCounter(driver->module, reloadVal);
        /* Clear SPE_RCMP_IRQ */
        IfxEgtm_Spe_clearInterrupt(driver->module, IfxEgtm_Spe_InterruptSignal_rcmp);
    }
}

/* This function is called when Z signal occurs after a rotation
 * */
void IfxEgtm_IncrEnc_onZeroIrq(IfxEgtm_IncrEnc* driver)
{
    if (driver->notSynchronised)
    {
        driver->notSynchronised = 0;
    }

    if (driver->direction == IfxEgtm_Spe_Direction_fwd)
    {
        driver->turn++;
    }
    else
    {
        driver->turn--;
    }
}
