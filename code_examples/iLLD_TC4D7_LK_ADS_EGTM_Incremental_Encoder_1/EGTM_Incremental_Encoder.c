/**********************************************************************************************************************
 * \file EGTM_Incremental_Encoder.c
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <EGTM_Incremental_Encoder.h>
#include "IfxPort.h"
#include "IfxStm.h"
#include "Ifx_Types.h"
#include "IfxSrc_reg.h"
#include <stddef.h>
#include <float.h>
#include <math.h>

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

#define ISR_PRIORITY_SPE            8                               /* EGTM SPE interrupt priority                   */
#define ISR_PROVIDER                IfxSrc_Tos_cpu0                 /* Interrupt provider                            */
#define ISR_PRIORITY_PINZ           7                               /* EGTM TIM interrupt priority                   */

#define UPDATE_FREQ_HZ              10000                           /* Encoder function update frequency.            */
#define SPEED_UPDATE_RATE           50                              /* Speed update frequency; UPDATE_FREQ_HZ scaled */
#define SPEED_MIN_RPM               (0.0f)                          /* Minimum speed limit value.                    */
#define SPEED_MAX_RPM               (2000.0f)                       /* Maximum speed limit value.                    */

#define ENCODER_OFFSET              0                               /* Encoder offset                                */
#define ENCODER_RESOLUTION          2048                            /* Encoder resolution - pulses per revolution.   */
#define ENCODER_UPDATE_PERIOD       (1/ ((float32)UPDATE_FREQ_HZ))  /* Encoder function update period.               */

#define ENCODER_BASE_MIN_SPEED      (float32) (SPEED_MIN_RPM / 60.0 * 2 * IFX_PI) /* Minimum base speed              */
#define ENCODER_BASE_MAX_SPEED      (float32) (SPEED_MAX_RPM / 60.0 * 2 * IFX_PI) /* Maximum base speed              */
#define ENCODER_EMULATOR_PIN_A      &MODULE_P00, 11                 /* Encoder emulator pin A                        */
#define ENCODER_EMULATOR_PIN_B      &MODULE_P00, 10                 /* Encoder emulator pin B                        */
#define ENCODER_EMULATOR_PIN_Z      &MODULE_P02, 12                 /* Encoder emulator pin Z                        */
#define ENCODER_EMULATOR_SPEED      5                               /* Encoder emulator initial speed [rad/s]        */

#define SPE_CLUSTER                 0                               /* Cluster of the SPE used                       */
#define TIM_SEL                     0                               /* SPE TIM input selection; SPE0: TIM0_CH0..2    */
#define ENCODER_EGTM_PIN_A          &IfxEgtm_TIM0_2_P00_11_IN       /* TIM pin for Encoder pin A                     */
#define ENCODER_EGTM_PIN_B          &IfxEgtm_TIM0_1_P00_10_IN       /* TIM pin for Encoder pin B                     */
#define ENCODER_EGTM_PIN_Z          &IfxEgtm_TIM0_3_P00_12_IN       /* TIM pin for Encoder pin Z                     */


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

Encoder          g_encoderEmulation;    /* Encoder emulator structure                                                */
uint32           g_intCount;            /* Interrupt counter                                                         */
IfxEgtm_IncrEnc  g_egtmIncrEnc;         /* Incremental encoder handle                                                */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

IFX_INTERRUPT(interruptSpe, 0, ISR_PRIORITY_SPE);
IFX_INTERRUPT(interruptGtm, 0, ISR_PRIORITY_PINZ);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/* Function to initialize the EGTM blocks SPE, TIM and the port for the incremental encoder functionality */
void initEgtmTimer(void)
{
    IfxEgtm_IncrEnc_Config egtmConfig;
    IfxEgtm_IncrEnc_initConfig(&egtmConfig, &MODULE_EGTM.CLS[SPE_CLUSTER].SPE);

    /*  Encoder configurations, SPE used as position acquisition core */
    /* Sensor resolution (number of pulses per revolution) */
    egtmConfig.resolution         = ENCODER_RESOLUTION;
    /* Configure position sensor offset */
    egtmConfig.offset             = ENCODER_OFFSET;

    /* Configure speed parameters */
    /* Number of samples to be considered */
    egtmConfig.speedUpdate        = SPEED_UPDATE_RATE;
    /* Absolute minimal allowed speed. below speed is recognized as 0 rad/s */
    egtmConfig.minSpeed           = ENCODER_BASE_MIN_SPEED;
    /* Absolute maximal allowed speed. Above speed is recognized as error */
    egtmConfig.maxSpeed           = ENCODER_BASE_MAX_SPEED;
    /* Update period in seconds */
    egtmConfig.updatePeriod       = ENCODER_UPDATE_PERIOD;

    /* Configure for interrupts */
    /* Interrupt isrPriority of the EGTM SPE interrupt */
    egtmConfig.speIsrPriority     = ISR_PRIORITY_SPE;
    /* Interrupt isrPriority of the EGTM TIM interrupt */
    egtmConfig.zeroIsrPriority    = ISR_PRIORITY_PINZ;
    /* Interrupt service provider for the zero interrupt */
    egtmConfig.zeroIsrProvider    = ISR_PROVIDER;

    /* Configure Hardware Resources */
    egtmConfig.pinA               = ENCODER_EGTM_PIN_A;                   /* Encoder A signal, connected to TIM0_0  */
    egtmConfig.pinB               = ENCODER_EGTM_PIN_B;                   /* Encoder B signal, connected to TIM0_1  */
    egtmConfig.pinZ               = ENCODER_EGTM_PIN_Z;                   /* Encoder Z signal, connected to TIM0_2  */
    egtmConfig.pinMode            = IfxPort_InputMode_noPullDevice;      /* Pad Driver                             */
    egtmConfig.timSel             = TIM_SEL;                             /* SPE TIM selection configuration        */
    egtmConfig.speCluster         = SPE_CLUSTER;                         /* Cluster of the SPE used                */

    /* Initialize the Incremental Encoder handle */
    IfxEgtm_IncrEnc_init(&g_egtmIncrEnc, &egtmConfig);
}

/* Interrupt Service Routine of the EGTM SPE_RCMP_IRQ; used to handle the overflow condition of SPE_REV_CNT  */
void interruptSpe(void)
{
    IfxEgtm_IncrEnc_handleOverflow(&g_egtmIncrEnc);
}

/* Interrupt Service Routine of the EGTM TIM; triggers when Z signal occurs*/
void interruptGtm(void)
{
    g_intCount++;
    IfxEgtm_IncrEnc_onZeroIrq(&g_egtmIncrEnc);
}

/* Function to initialize the incremental encoder simulation */
void initEncoderEmulation(void)
{
    /* Run encoder emulation after initialization */
    g_encoderEmulation.control.run                  = TRUE;
    /* Set initial direction */
    g_encoderEmulation.control.direction            = IfxEgtm_Spe_Direction_fwd;
    /* Sensor resolution (number of pulses per revolution) */
    g_encoderEmulation.control.resolution           = ENCODER_RESOLUTION;
    /* Set initial step*/
    g_encoderEmulation.control.step                 = 3;
    /* Set initial expected raw position */
    g_encoderEmulation.control.rawPosition          = 0;
    /* Set initial requested encoder speed in rad/s */
    g_encoderEmulation.control.speed                = ENCODER_EMULATOR_SPEED;
    /* Set encoder multiplication factor */
    g_encoderEmulation.control.multiplicationFactor = IfxStdIf_Pos_ResolutionFactor_fourFold;
    /* Set refresh period */
    g_encoderEmulation.control.updatePeriod         = ENCODER_UPDATE_PERIOD;
    /* Set mask for rawPosition value */
    g_encoderEmulation.control.positionMask         = g_encoderEmulation.control.resolution * g_encoderEmulation.control.multiplicationFactor - 1;
    /* Initialize encoder emulator pins */
    IfxPort_setPinMode(ENCODER_EMULATOR_PIN_A, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(ENCODER_EMULATOR_PIN_B, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(ENCODER_EMULATOR_PIN_Z, IfxPort_Mode_outputPushPullGeneral);
}

/* Function to execute encoder emulator step */
void doEncoderEmulationStep(void)
{
    if (g_encoderEmulation.control.run)
    {
        sint32 rawPosition;
        rawPosition = g_encoderEmulation.control.rawPosition;

        if (g_encoderEmulation.control.direction == IfxEgtm_Spe_Direction_fwd)
        {
            g_encoderEmulation.control.step++;
            g_encoderEmulation.control.step &= 0x3;
            rawPosition++;
        }
        else
        {
            g_encoderEmulation.control.step--;
            g_encoderEmulation.control.step &= 0x3;
            rawPosition--;
        }

        rawPosition &= g_encoderEmulation.control.positionMask;
        g_encoderEmulation.control.rawPosition = rawPosition;

        /* Handle zero pin */
        if (g_encoderEmulation.control.direction == IfxEgtm_Spe_Direction_fwd)
        {
            if (rawPosition == 0)
            {
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_Z, IfxPort_State_high);
            }
            else if (rawPosition == 1)
            {
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_Z, IfxPort_State_low);
            }
        }
        else
        {
            if (rawPosition == g_encoderEmulation.control.positionMask)
            {
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_Z, IfxPort_State_high);
            }
            else if (rawPosition == g_encoderEmulation.control.positionMask - 1)
            {
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_Z, IfxPort_State_low);
            }
        }
        /* Handle A and B pins */
        switch (g_encoderEmulation.control.step)
        {
            case 0:
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_A, IfxPort_State_low);
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_B, IfxPort_State_low);
                break;
            case 1:
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_A, IfxPort_State_low);
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_B, IfxPort_State_high);
                break;
            case 2:
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_A, IfxPort_State_high);
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_B, IfxPort_State_high);
                break;
            case 3:
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_A, IfxPort_State_high);
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_B, IfxPort_State_low);
                break;
            default:
                break;
        }
    }
}

/* Function to execute encoder emulator */
void doEncoderEmulation(void)
{
    Ifx_TickTime tickPeriod;
    Ifx_TickTime tickRefresh;

    Ifx_TickTime refreshDeadLine;
    Ifx_TickTime tickDeadLine;

    tickRefresh     = g_encoderEmulation.control.updatePeriod * TimeConst_1s;

    refreshDeadLine = IfxStm_now(); /* Get the STM counter value */
    tickDeadLine    = refreshDeadLine;

    while (1)
    {
        g_encoderEmulation.control.run = g_encoderEmulation.control.speed != 0.0;

        if (!g_encoderEmulation.control.run)
        {}
        else
        {
            if(g_encoderEmulation.control.speed < 0)
            {
                g_encoderEmulation.control.speed = 0;
            }

            float32 roundDuration_s = (2.0 * IFX_PI) / g_encoderEmulation.control.speed;
            float32 tickDuration_s  = roundDuration_s / (g_encoderEmulation.control.positionMask + 1);

            tickPeriod = tickDuration_s * TimeConst_1s;

            /* Check if tick deadline has occurred */
            if (IfxStm_isDeadLine(tickDeadLine))
            {
                tickDeadLine = addTTime(tickDeadLine, tickPeriod);
                doEncoderEmulationStep(); /* Execute encoder emulator step */
            }
        }
        /* Check if refresh deadline has occurred */
        if (IfxStm_isDeadLine(refreshDeadLine))
        {
            refreshDeadLine = addTTime(refreshDeadLine, tickRefresh);

            /* Update encoder driver */
            IfxEgtm_IncrEnc_update(&g_egtmIncrEnc);

            /* Get speed, raw position and direction */
            g_encoderEmulation.status.speed       = IfxEgtm_IncrEnc_getSpeed(&g_egtmIncrEnc);
            g_encoderEmulation.status.rawPosition = IfxEgtm_IncrEnc_getRawPosition(&g_egtmIncrEnc);
            g_encoderEmulation.status.direction   = IfxEgtm_IncrEnc_getDirection(&g_egtmIncrEnc);
        }
    }
}
