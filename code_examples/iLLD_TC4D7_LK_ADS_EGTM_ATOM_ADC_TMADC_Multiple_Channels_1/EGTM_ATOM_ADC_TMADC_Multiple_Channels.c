/**********************************************************************************************************************
 * \file EGTM_ATOM_ADC_TMADC_Multiple_Channels.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "EGTM_ATOM_ADC_TMADC_Multiple_Channels.h"
#include "Ifx_Types.h"
#include "IfxEgtm_Pwm.h"
#include "IfxPort.h"
#include "IfxPort_Pinmap.h"
#include "IfxAdc_Tmadc.h"
#include "IfxEgtm_Trigger.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define NUM_OF_CHANNELS          (3)                                   /* Number of PWM complementary pairs          */
#define NUM_OF_ADC_TRIG_CHANNELS (1)                                   /* Number of ADC trigger signals              */
#define NUM_OF_ADC_CHANNELS      (5)                                   /* Number of ADC channels                     */

#define PWM_FREQUENCY          (20.0E3)                                /* PWM frequency in [Hz]                      */
#define ISR_PRIORITY_ATOM      (20)                                    /* Interrupt priority number                  */
#define IFX_INTPRIO_TMADC_SR0  (25)

#define PHASE_U_HS              &IfxEgtm_ATOM0_0_TOUT64_P20_8_OUT      /* Pin which will be driven by the PWM, P20.8 */
#define PHASE_U_LS              &IfxEgtm_ATOM0_0N_TOUT65_P20_9_OUT     /* Pin which will be driven by the PWM, P20.9 */
#define PHASE_V_HS              &IfxEgtm_ATOM0_1_TOUT66_P20_10_OUT     /* Pin which will be driven by the PWM, P20.10*/
#define PHASE_V_LS              &IfxEgtm_ATOM0_1N_TOUT67_P20_11_OUT    /* Pin which will be driven by the PWM, P20.11*/
#define PHASE_W_HS              &IfxEgtm_ATOM0_2_TOUT68_P20_12_OUT     /* Pin which will be driven by the PWM, P20.12*/
#define PHASE_W_LS              &IfxEgtm_ATOM0_2N_TOUT69_P20_13_OUT    /* Pin which will be driven by the PWM, P20.13*/

#define PHASE_U_DUTY            (25.0f)                                /* Initial PWM duty cycle of phase U in [%]   */
#define PHASE_V_DUTY            (50.0f)                                /* Initial PWM duty cycle of phase V in [%]   */
#define PHASE_W_DUTY            (75.0f)                                /* Initial PWM duty cycle of phase W in [%]   */
#define PHASE_DUTY_STEP         (10.0f)                                /* PWM duty cycle step in [%]                 */

#define ADC_TRIG_DUTY           (50.0f)                                /* Initial PWM duty cycle in [%]              */
#define ADC_TRIG_OUT            &IfxEgtm_ATOM0_3_TOUT22_P33_0_OUT      /* Pin which will be driven by the PWM, P33.0 */

#define LED                     &MODULE_P03, 9       /* LED which will be toggled in Interrupt Service Routine (ISR) */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
typedef struct
{
    IfxEgtm_Pwm          pwm;                                  /* PWM Driver handle                                  */
    IfxEgtm_Pwm_Channel  channels[NUM_OF_CHANNELS];            /* Array containing channel data after configuration  */
    float32              dutyCycles[NUM_OF_CHANNELS];          /* Duty Cycle values to hold                          */
    float32              phases[NUM_OF_CHANNELS];              /* PhaseShift values to hold                          */
    IfxEgtm_Pwm_DeadTime deadTimes[NUM_OF_CHANNELS];           /* PhaseShift values to hold                          */
} EgtmAtom3phInv;

typedef struct
{
    IfxEgtm_Pwm          pwm;                                  /* PWM Driver handle                                  */
    IfxEgtm_Pwm_Channel  channels[NUM_OF_ADC_TRIG_CHANNELS];   /* Array containing channel data after configuration  */
    float32              dutyCycles[NUM_OF_ADC_TRIG_CHANNELS]; /* Duty Cycle values to hold                          */
    float32              phases[NUM_OF_ADC_TRIG_CHANNELS];     /* PhaseShift values to hold                          */
    IfxEgtm_Pwm_DeadTime deadTimes[NUM_OF_ADC_TRIG_CHANNELS];  /* PhaseShift values to hold                          */
} EgtmAtomTrigToAdc;

IfxAdc_Tmadc g_tmadc;                                        /* TMADC module handle                                  */
IfxAdc_Tmadc_Ch g_tmadcChannel[NUM_OF_ADC_CHANNELS];         /* TMADC channel handle                                 */
volatile uint16  g_result[NUM_OF_ADC_CHANNELS];              /* Variable to store the result of the measurement      */
IFX_STATIC EgtmAtom3phInv g_egtmAtom3phInv;                  /* Structure for PWM generation                         */
IFX_STATIC EgtmAtomTrigToAdc g_egtmAtomTrigToAdc;            /* Structure for ADC trigger generation                 */

/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/

/* Macro to define the Interrupt Service Routine. */
IFX_INTERRUPT(resultISR, 0, IFX_INTPRIO_TMADC_SR0);

/* Interrupt Service Routine of the TMADC */
void resultISR(void)
{
    /* Read result values. */
    g_result[0] = IfxAdc_Tmadc_readChannelResult(&g_tmadcChannel[0]);
    g_result[1] = IfxAdc_Tmadc_readChannelResult(&g_tmadcChannel[1]);
    g_result[2] = IfxAdc_Tmadc_readChannelResult(&g_tmadcChannel[2]);
    g_result[3] = IfxAdc_Tmadc_readChannelResult(&g_tmadcChannel[3]);
    g_result[4] = IfxAdc_Tmadc_readChannelResult(&g_tmadcChannel[4]);
}

/* This function initializes the TOM */
void initEgtmAtom(void)
{

    /* Configuration variables
     * Neither application (in most of the cases) nor the PWM driver need configuration variables post initialization.
     * Hence it is recommended to define such variables within the function (STACK).
     * Alternatively such structures could also be initialized (element-wise) as constant (in ROM)
     */
    IfxEgtm_Pwm_Config config3ph;                               /* Main PWM configuration structure                  */
    IfxEgtm_Pwm_ChannelConfig channel3phConfig[NUM_OF_CHANNELS];/* Array containing configuration for each channel   */
    IfxEgtm_Pwm_DtmConfig dtm3phConfig[NUM_OF_CHANNELS];        /* DTM module configuration structure                */
    IfxEgtm_Pwm_InterruptConfig interrupt3phConfig;             /* Interrupt configuration structure                 */
    IfxEgtm_Pwm_OutputConfig output3ph[NUM_OF_CHANNELS];        /* Output configuration structure                    */

    /* 1. Config structure initialization
     * If the configuration structure is located in the RAM, the initConfig API would be handy to initialize the
     * elements to their default values
     */
    IfxEgtm_Pwm_initConfig(&config3ph, &MODULE_EGTM);

    /* 2. Output configuration */

    /* CH0 configurations */
    output3ph[0].pin                   = (IfxEgtm_Pwm_ToutMap*)PHASE_U_HS;         /* Phase U PWM High-side          */
    output3ph[0].complementaryPin      = (IfxEgtm_Pwm_ToutMap*)PHASE_U_LS;         /* Phase U PWM Low-side           */
    output3ph[0].polarity              = Ifx_ActiveState_high;                     /* Active low/high of pin         */
    output3ph[0].complementaryPolarity = Ifx_ActiveState_low;                      /* Active low/high of pin         */
    output3ph[0].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                    */
    output3ph[0].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                     */

    /* CH1 configurations */
    output3ph[1].pin                   = (IfxEgtm_Pwm_ToutMap*)PHASE_V_HS;         /* Phase V PWM High-side          */
    output3ph[1].complementaryPin      = (IfxEgtm_Pwm_ToutMap*)PHASE_V_LS;         /* Phase V PWM Low-side           */
    output3ph[1].polarity              = Ifx_ActiveState_high;                     /* Active low/high of pin         */
    output3ph[1].complementaryPolarity = Ifx_ActiveState_low;                      /* Active low/high of pin         */
    output3ph[1].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                    */
    output3ph[1].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                     */

    /* CH2 configurations */
    output3ph[2].pin                   = (IfxEgtm_Pwm_ToutMap*)PHASE_W_HS;         /* Phase W PWM High-side          */
    output3ph[2].complementaryPin      = (IfxEgtm_Pwm_ToutMap*)PHASE_W_LS;         /* Phase W PWM Low-side           */
    output3ph[2].polarity              = Ifx_ActiveState_high;                     /* Active low/high of pin         */
    output3ph[2].complementaryPolarity = Ifx_ActiveState_low;                      /* Active low/high of pin         */
    output3ph[2].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                    */
    output3ph[2].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                     */

    /* 3. Dead-time configuration */

    dtm3phConfig[0].deadTime.rising    = 1e-6f;                     /* Rising Dead time in seconds                   */
    dtm3phConfig[0].deadTime.falling   = 1e-6f;                     /* Falling Dead time in seconds                  */

    dtm3phConfig[1].deadTime.rising    = 1e-6f;                     /* Rising Dead time in seconds                   */
    dtm3phConfig[1].deadTime.falling   = 1e-6f;                     /* Falling Dead time in seconds                  */

    dtm3phConfig[2].deadTime.rising    = 1e-6f;                     /* Rising Dead time in seconds                   */
    dtm3phConfig[2].deadTime.falling   = 1e-6f;                     /* Falling Dead time in seconds                  */

    /* 4. Interrupt configuration, Example configuration of interrupt for base channel */

    interrupt3phConfig.mode          = IfxEgtm_IrqMode_pulseNotify; /* IRQ mode of interrupt                         */
    interrupt3phConfig.isrProvider   = IfxSrc_Tos_cpu0;             /* Type of Service                               */
    interrupt3phConfig.priority      = 0;                           /* Interrupt priority                            */
    interrupt3phConfig.vmId          = IfxSrc_VmId_0;               /* VM ID                                         */
    /* Connect callback function for period event interrupt */
    interrupt3phConfig.periodEvent   = NULL_PTR;
    interrupt3phConfig.dutyEvent     = NULL_PTR;                    /* Do not duty event interrupt                   */

    /*5. Channel configuration */

    /* Base channel - CH0 configuration */
    channel3phConfig[0].timerCh      = IfxEgtm_Pwm_SubModule_Ch_0;  /* Atom channel index to be used for base channel*/
    channel3phConfig[0].phase        = 0.0f;                        /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                     * only for edge aligned sync channels)          */
    channel3phConfig[0].duty         = PHASE_U_DUTY;                /* PWM duty in % (range: 0.0 .. 100.0)           */
    channel3phConfig[0].dtm          = &dtm3phConfig[0];            /* Attach Dead time configuration                */
    channel3phConfig[0].output       = &output3ph[0];               /* Attach Pin connections and polarities         */
    channel3phConfig[0].mscOut       = NULL_PTR;                    /* MSC configuration for this channel            */
    channel3phConfig[0].interrupt    = &interrupt3phConfig;         /* Attach Interrupt configuration                */

    /*Sync channel CH1 configuration. */
    channel3phConfig[1].timerCh      = IfxEgtm_Pwm_SubModule_Ch_1;  /* Atom channel index to be used for sync channel*/
    channel3phConfig[1].phase        = 0.0f;                        /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                     * only for edge aligned sync channels)          */
    channel3phConfig[1].duty         = PHASE_V_DUTY;                /* PWM duty in % (range: 0.0 .. 100.0)           */
    channel3phConfig[1].dtm          = &dtm3phConfig[0];            /* Dead time configuration for this channel      */
    channel3phConfig[1].output       = &output3ph[1];               /* Pin connections and polarities                */
    channel3phConfig[1].mscOut       = NULL_PTR;                    /* MSC configuration                             */
    channel3phConfig[1].interrupt    = NULL_PTR;                    /* Interrupt configuration                       */

    /*Sync channel CH2 configuration.*/
    channel3phConfig[2].timerCh      = IfxEgtm_Pwm_SubModule_Ch_2;  /* Atom channel index to be used for sync channel*/
    channel3phConfig[2].phase        = 0.0f;                        /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                     * only for edge aligned sync channels)          */
    channel3phConfig[2].duty         = PHASE_W_DUTY;                /* PWM duty in % (range: 0.0 .. 100.0)           */
    channel3phConfig[2].dtm          = &dtm3phConfig[0];            /* Dead time configuration for this channel      */
    channel3phConfig[2].output       = &output3ph[2];               /* Pin connections and polarities                */
    channel3phConfig[2].mscOut       = NULL_PTR;                    /* MSC configuration                             */
    channel3phConfig[2].interrupt    = NULL_PTR;                    /* Interrupt configuration for this channel      */

    /* 6. Other configurations */

    config3ph.cluster                = IfxEgtm_Cluster_0;           /* Cluster                                       */
    config3ph.subModule              = IfxEgtm_Pwm_SubModule_atom;  /* Sub module                                    */
    config3ph.alignment              = IfxEgtm_Pwm_Alignment_center;/* Alignment                                     */
    config3ph.syncStart              = FALSE;                       /* Start all channels after initialization       */
    config3ph.numChannels            = NUM_OF_CHANNELS;             /* Number of channels configured                 */
    config3ph.channels               = channel3phConfig;            /* Attach Channel configuration                  */
    config3ph.frequency              = PWM_FREQUENCY;               /* PWM frequency                                 */
    config3ph.clockSource.atom       = IfxEgtm_Cmu_Clk_0;           /* Clock source for atom                         */
    config3ph.dtmClockSource         = IfxEgtm_Dtm_ClockSource_cmuClock0; /* Clock source for dtm                    */
    config3ph.syncUpdateEnabled      = TRUE;                        /* TRUE: Update compare registers from shadow
                                                                     * at the end of period                          */

    /*****************************************************************************************************************/
    /* ADC TMADC Trigger Configuration                                                                               */
    /*****************************************************************************************************************/

    /* Configuration variables */

    IfxEgtm_Pwm_Config configAdcTrig;                                        /* Main ADC trigger config. structure   */
    IfxEgtm_Pwm_ChannelConfig channelAdcTrigConfig[NUM_OF_ADC_TRIG_CHANNELS];/* Channel configuration structure      */
    IfxEgtm_Pwm_OutputConfig outputAdcTrig[NUM_OF_ADC_TRIG_CHANNELS];        /* Output configuration structure       */

    /* 1. Config structure initialization
     * If the configuration structure is located in the RAM, the initConfig API would be handy to initialize the
     * elements to their default values
     */
    IfxEgtm_Pwm_initConfig(&configAdcTrig, &MODULE_EGTM);

    /* 2. Output configuration */

    /* CH0 configurations */
    outputAdcTrig[0].pin                   = (IfxEgtm_Pwm_ToutMap*)ADC_TRIG_OUT;      /* Phase U PWM High-side       */
    outputAdcTrig[0].polarity              = Ifx_ActiveState_low;                     /* Active low/high of pin      */
    outputAdcTrig[0].outputMode            = IfxPort_OutputMode_pushPull;             /* Output mode                 */
    outputAdcTrig[0].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;  /* Pad driver                  */

    /*3. Channel configuration */

    /* Base channel - CH0 configuration */
    channelAdcTrigConfig[0].timerCh      = IfxEgtm_Pwm_SubModule_Ch_3;  /* Atom channel index                        */
    channelAdcTrigConfig[0].phase        = 0.0f;                        /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                         * only for edge aligned sync channels)      */
    channelAdcTrigConfig[0].duty         = ADC_TRIG_DUTY;               /* PWM duty in % (range: 0.0 .. 100.0)       */
    channelAdcTrigConfig[0].dtm          = NULL_PTR;                    /* Attach Dead time configuration            */
    channelAdcTrigConfig[0].output       = &outputAdcTrig[0];           /* Attach Pin connections and polarities     */
    channelAdcTrigConfig[0].mscOut       = NULL_PTR;                    /* MSC configuration for this channel        */
    channelAdcTrigConfig[0].interrupt    = NULL_PTR;                    /* Attach Interrupt configuration            */

    /* 4. Other configurations */

    configAdcTrig.cluster                = IfxEgtm_Cluster_0;           /* Cluster                                   */
    configAdcTrig.subModule              = IfxEgtm_Pwm_SubModule_atom;  /* Sub module                                */
    configAdcTrig.alignment              = IfxEgtm_Pwm_Alignment_edge;  /* Alignment                                 */
    configAdcTrig.syncStart              = FALSE;                       /* Start all channels after init             */
    configAdcTrig.numChannels            = NUM_OF_ADC_TRIG_CHANNELS;    /* Number of channels configured             */
    configAdcTrig.channels               = channelAdcTrigConfig;        /* Attach Channel configuration              */
    configAdcTrig.frequency              = PWM_FREQUENCY;               /* PWM frequency                             */
    configAdcTrig.clockSource.atom       = IfxEgtm_Cmu_Clk_0;           /* Clock source for atom                     */
    configAdcTrig.syncUpdateEnabled      = TRUE;                        /* TRUE: Update compare registers from shadow
                                                                         * at the end of period                      */

    /* 5. Call the init function */

    if(!IfxEgtm_isEnabled(&MODULE_EGTM))
    {
        float32 frequency;
        /* Enable EGTM, it is necessary if the EGTM is not initialized earlier */
        IfxEgtm_enable(&MODULE_EGTM);

        frequency = IfxEgtm_Cmu_getModuleFrequency(&MODULE_EGTM);
        /* Set the global clock frequency to the max */
        IfxEgtm_Cmu_setGclkFrequency(&MODULE_EGTM, frequency);
        /* Set the CMU CLK0 */
        IfxEgtm_Cmu_setClkFrequency(&MODULE_EGTM, IfxEgtm_Cmu_Clk_0, frequency);
        /* Enable the FXU clock */
        IfxEgtm_Cmu_enableClocks(&MODULE_EGTM, IFXEGTM_CMU_CLKEN_CLK0);
    }

    IfxEgtm_Trigger_trigToAdc(IfxEgtm_Cluster_0, IfxEgtm_TrigSource_atom,
            IfxEgtm_TrigChannel_3,
            IfxEgtm_Cfg_AdcTriggerSignal_0); /* TMADC Triggered by EGTM ATOM0 CH3 */

    IfxEgtm_Pwm_init(&g_egtmAtom3phInv.pwm, &g_egtmAtom3phInv.channels[0], &config3ph);
    /*   IfxGtm_Pwm_startSyncedChannels(&g_gtmTom3phInv.pwm); */
    IfxEgtm_Pwm_init(&g_egtmAtomTrigToAdc.pwm, &g_egtmAtomTrigToAdc.channels[0], &configAdcTrig);

    IfxEgtm_Pwm_startSyncedGroups(&g_egtmAtom3phInv.pwm, &g_egtmAtomTrigToAdc.pwm);

    /** Store the current duty values for runtime calls */
    g_egtmAtom3phInv.dutyCycles[0]= channel3phConfig[0].duty;
    g_egtmAtom3phInv.dutyCycles[1]= channel3phConfig[1].duty;
    g_egtmAtom3phInv.dutyCycles[2]= channel3phConfig[2].duty;
    /** Store the current duty values for runtime calls */
    g_egtmAtom3phInv.deadTimes[0]= channel3phConfig[0].dtm->deadTime;
    g_egtmAtom3phInv.deadTimes[1]= channel3phConfig[1].dtm->deadTime;
    g_egtmAtom3phInv.deadTimes[2]= channel3phConfig[2].dtm->deadTime;
    /** Store the current duty values for runtime calls */
    g_egtmAtom3phInv.dutyCycles[0]= channelAdcTrigConfig[0].duty;

    IfxPort_setPinModeOutput(LED, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);   /* Set pin mode         */
}

/* Update duty cycles */
void updateEgtmAtomDuty(void)
{
    if((g_egtmAtom3phInv.dutyCycles[0] + PHASE_DUTY_STEP) >= 100)
    {
        g_egtmAtom3phInv.dutyCycles[0] = 0;                                /* Set duty to zero                       */
    }
    if((g_egtmAtom3phInv.dutyCycles[1] + PHASE_DUTY_STEP) >= 100)
    {
        g_egtmAtom3phInv.dutyCycles[1] = 0;                                /* Set duty to zero                       */
    }
    if((g_egtmAtom3phInv.dutyCycles[2] + PHASE_DUTY_STEP) >= 100)
    {
        g_egtmAtom3phInv.dutyCycles[2] = 0;                                 /* Set duty to zero                      */
    }

    g_egtmAtom3phInv.dutyCycles[0] += PHASE_DUTY_STEP;                      /* Increment PWM duty cycle of phase U   */
    g_egtmAtom3phInv.dutyCycles[1] += PHASE_DUTY_STEP;                      /* Increment PWM duty cycle of phase V   */
    g_egtmAtom3phInv.dutyCycles[2] += PHASE_DUTY_STEP;                      /* Increment PWM duty cycle of phase W   */

    /* Update duty of all configured channels to requested values immediately */
    IfxEgtm_Pwm_updateChannelsDutyImmediate(&g_egtmAtom3phInv.pwm, (float32*)g_egtmAtom3phInv.dutyCycles);
}


/* TMADC */

/* Function to initialize and run the TMADC */
void initTMADC(void)
{
    /* Initialize the TMADC module */
    initTMADCModule();
    /* Initialize the channel */
    initTMADCChannels();
    /* Run the TMADC module */
    IfxAdc_Tmadc_runModule(&g_tmadc);
}

/* Function to initialize the TMADC module */
void initTMADCModule(void)
{
    IfxAdc_Tmadc_Config tmadcConfig;                           /* TMADC configuration structure                      */
    IfxAdc_Tmadc_InterruptConfig tmadcIntConfig;               /* TMADC interrupt configuration                      */
    IfxAdc_Tmadc_ServRequestConfig tmadcServRequestConfig;     /* TMADC interrupt service request configuration      */

    /* Enable ADC module */
    IfxAdc_enableModule(&MODULE_ADC);

    /* Initialize module to default */
    IfxAdc_Tmadc_initModuleConfig(&tmadcConfig, &MODULE_ADC);

    /* Change TMADC configuration */
    tmadcConfig.id                = IfxAdc_TmadcModule_0;               /* Module ID                                 */
    tmadcConfig.calEnable         = FALSE;                              /* Calibration enabled                       */

    /* Set TMADC Interrupt configuration */
    tmadcIntConfig.node          = IfxAdc_TmadcServReq_0;               /* Select service request node               */
    tmadcIntConfig.eventOp       = IfxAdc_TmadcEventOp_andLogic;        /* Select service request event operation    */
    tmadcIntConfig.eventSel      = IfxAdc_TmadcEventSel_result;         /* Select TMADC event                        */
    tmadcIntConfig.typeOfService = IfxSrc_Tos_cpu0;                     /* Set interrupt provider                    */
    /* Set identifier of Virtual machine interrupt service provider         */
    tmadcIntConfig.vmId          = IfxSrc_VmId_0;
    tmadcIntConfig.priority      = IFX_INTPRIO_TMADC_SR0;               /* Set Channel event priority                */

    tmadcServRequestConfig.intConfig[0] = &tmadcIntConfig;     /* Register correct interrupt configuration           */
    tmadcServRequestConfig.numServReqNodes = 1;                /* Configure number of interrupt service requests     */

    tmadcConfig.srvReqCfg = &tmadcServRequestConfig;           /* Assign the correct service request configuration   */

    /* Initialize TMADC module with updated configuration */
    IfxAdc_Tmadc_initModule(&g_tmadc, &tmadcConfig);

    /*Initialize TMADC service request configuration register 0 */
    {
        Ifx_ADC_TMADC_SR_CFG srCfg;
        srCfg.U = ADC_TMADC0_SR0_CFG.U;
        srCfg.B.EVEN = 0x001F;             /* Service request generation on occurrence of all event (channels 0 - 4) */
        ADC_TMADC0_SR0_CFG.U = srCfg.U;
    }
}

/* Function to initialize the TMADC channel */
void initTMADCChannels(void)
{
    IfxAdc_Tmadc_ChConfig tmadcChannelConfig[NUM_OF_ADC_CHANNELS];  /* TMADC channel configuration structure         */
    IfxAdc_Tmadc_ChannelServReqConfig tmacChannelServRequest[NUM_OF_ADC_CHANNELS]; /* TMADC channel service request  */

    /*****************************************************************************************************************/
    /* TMADC Module 0, Channel 0                                                                                     */
    /*****************************************************************************************************************/

    /* Initialize the configuration with default values */
    IfxAdc_Tmadc_initChannelConfig(&tmadcChannelConfig[0], &MODULE_ADC);
    /* Change TMADC channel configuration */

    /* Select the channel ID and the respective result register */
    tmadcChannelConfig[0].id             = IfxAdc_TmadcChannel_0;          /* Channel ID                             */
    tmadcChannelConfig[0].moduleId       = IfxAdc_TmadcModule_0;           /* Select TMADC module                    */
    tmadcChannelConfig[0].samplingTimeNS = 100;                            /* Set sampling time period               */
    tmadcChannelConfig[0].mode           = IfxAdc_TmadcOpMode_oneShot;     /* Select operating mode - one shot       */
    tmadcChannelConfig[0].core           = IfxAdc_TmadcSarCore_0;          /* Select TMADC SAR core                  */

    tmadcChannelConfig[0].resultCfg.resultReg   = IfxAdc_TmadcResultReg_0; /* Configure result register              */
    tmadcChannelConfig[0].resultCfg.waitForRead = TRUE;                    /* Enable wait-for-read mode              */

    IfxAdc_Tmadc_ChannelTriggerConfig trigger = {{IfxAdc_TmadcTriggerMuxSel_36, IfxAdc_TmadcTriggerMode_fallingEdge},
            {IfxAdc_TmadcTriggerMuxSel_0, IfxAdc_TmadcTriggerMode_disable}, 0};
    tmadcChannelConfig[0].trigger = &trigger;

    /* Set channel service request */
    tmacChannelServRequest[0].errorNode     = IfxAdc_TmadcServReq_none;    /* Configure Service request error node   */
    tmacChannelServRequest[0].boundaryNode  = IfxAdc_TmadcServReq_none;    /* Configure Service request boundary node*/
    tmacChannelServRequest[0].resultNode    = IfxAdc_TmadcServReq_0;       /* Configure Service request result node  */

    /* Assign configured channel service request to configuration */
    tmadcChannelConfig[0].channelSrvReq = &tmacChannelServRequest[0];

    /* Initialize the channel */
    IfxAdc_Tmadc_initChannel(&g_tmadcChannel[0], &tmadcChannelConfig[0]);

    /*****************************************************************************************************************/
    /* TMADC Module 0, Channel 1                                                                                     */
    /*****************************************************************************************************************/

    /* Initialize the configuration with default values */
    IfxAdc_Tmadc_initChannelConfig(&tmadcChannelConfig[1], &MODULE_ADC);
    /* Change TMADC channel configuration */

    /* Select the channel ID and the respective result register */
    tmadcChannelConfig[1].id             = IfxAdc_TmadcChannel_1;          /* Channel ID                             */
    tmadcChannelConfig[1].moduleId       = IfxAdc_TmadcModule_0;           /* Select TMADC module                    */
    tmadcChannelConfig[1].samplingTimeNS = 100;                            /* Set sampling time period               */
    tmadcChannelConfig[1].mode           = IfxAdc_TmadcOpMode_oneShot;     /* Select operating mode - one shot       */
    tmadcChannelConfig[1].core           = IfxAdc_TmadcSarCore_0;          /* Select TMADC SAR core                  */

    tmadcChannelConfig[1].resultCfg.resultReg   = IfxAdc_TmadcResultReg_1; /* Configure result register              */
    tmadcChannelConfig[1].resultCfg.waitForRead = TRUE;                    /* Enable wait-for-read mode              */

    tmadcChannelConfig[1].trigger = &trigger;

    /* Set channel service request */
    tmacChannelServRequest[1].errorNode     = IfxAdc_TmadcServReq_none;    /* Configure Service request error node   */
    tmacChannelServRequest[1].boundaryNode  = IfxAdc_TmadcServReq_none;    /* Configure Service request boundary node*/
    tmacChannelServRequest[1].resultNode    = IfxAdc_TmadcServReq_0;       /* Configure Service request result node  */

    /* Assign configured channel service request to configuration */
    tmadcChannelConfig[1].channelSrvReq = &tmacChannelServRequest[0];

    /* Initialize the channel */
    IfxAdc_Tmadc_initChannel(&g_tmadcChannel[1], &tmadcChannelConfig[1]);

    /*****************************************************************************************************************/
    /* TMADC Module 0, Channel 2                                                                                     */
    /*****************************************************************************************************************/

    /* Initialize the configuration with default values */
    IfxAdc_Tmadc_initChannelConfig(&tmadcChannelConfig[2], &MODULE_ADC);
    /* Change TMADC channel configuration */

    /* Select the channel ID and the respective result register */
    tmadcChannelConfig[2].id             = IfxAdc_TmadcChannel_2;          /* Channel ID                             */
    tmadcChannelConfig[2].moduleId       = IfxAdc_TmadcModule_0;           /* Select TMADC module                    */
    tmadcChannelConfig[2].samplingTimeNS = 100;                            /* Set sampling time period               */
    tmadcChannelConfig[2].mode           = IfxAdc_TmadcOpMode_oneShot;     /* Select operating mode - one shot       */
    tmadcChannelConfig[2].core           = IfxAdc_TmadcSarCore_0;          /* Select TMADC SAR core                  */

    tmadcChannelConfig[2].resultCfg.resultReg   = IfxAdc_TmadcResultReg_2; /* Configure result register              */
    tmadcChannelConfig[2].resultCfg.waitForRead = TRUE;                    /* Enable wait-for-read mode              */

    tmadcChannelConfig[2].trigger = &trigger;

    /* Set channel service request */
    tmacChannelServRequest[2].errorNode     = IfxAdc_TmadcServReq_none;    /* Configure Service request error node   */
    tmacChannelServRequest[2].boundaryNode  = IfxAdc_TmadcServReq_none;    /* Configure Service request boundary node*/
    tmacChannelServRequest[2].resultNode    = IfxAdc_TmadcServReq_0;       /* Configure Service request result node  */

    /* Assign configured channel service request to configuration */
    tmadcChannelConfig[2].channelSrvReq = &tmacChannelServRequest[2];

    /* Initialize the channel */
    IfxAdc_Tmadc_initChannel(&g_tmadcChannel[2], &tmadcChannelConfig[2]);

    /*****************************************************************************************************************/
    /* TMADC Module 0, Channel 3                                                                                     */
    /*****************************************************************************************************************/

    /* Initialize the configuration with default values */
    IfxAdc_Tmadc_initChannelConfig(&tmadcChannelConfig[3], &MODULE_ADC);
    /* Change TMADC channel configuration */

    /* Select the channel ID and the respective result register */
    tmadcChannelConfig[3].id             = IfxAdc_TmadcChannel_3;          /* Channel ID                             */
    tmadcChannelConfig[3].moduleId       = IfxAdc_TmadcModule_0;           /* Select TMADC module                    */
    tmadcChannelConfig[3].samplingTimeNS = 100;                            /* Set sampling time period               */
    tmadcChannelConfig[3].mode           = IfxAdc_TmadcOpMode_oneShot;     /* Select operating mode - one shot       */
    tmadcChannelConfig[3].core           = IfxAdc_TmadcSarCore_0;          /* Select TMADC SAR core                  */

    tmadcChannelConfig[3].resultCfg.resultReg   = IfxAdc_TmadcResultReg_3; /* Configure result register              */
    tmadcChannelConfig[3].resultCfg.waitForRead = TRUE;                    /* Enable wait-for-read mode              */

    tmadcChannelConfig[3].trigger = &trigger;

    /* Set channel service request */
    tmacChannelServRequest[3].errorNode     = IfxAdc_TmadcServReq_none;    /* Configure Service request error node   */
    tmacChannelServRequest[3].boundaryNode  = IfxAdc_TmadcServReq_none;    /* Configure Service request boundary node*/
    tmacChannelServRequest[3].resultNode    = IfxAdc_TmadcServReq_0;       /* Configure Service request result node  */

    /* Assign configured channel service request to configuration */
    tmadcChannelConfig[3].channelSrvReq = &tmacChannelServRequest[3];

    /* Initialize the channel */
    IfxAdc_Tmadc_initChannel(&g_tmadcChannel[3], &tmadcChannelConfig[3]);

    /*****************************************************************************************************************/
    /* TMADC Module 0, Channel 4                                                                                     */
    /*****************************************************************************************************************/

    /* Initialize the configuration with default values */
    IfxAdc_Tmadc_initChannelConfig(&tmadcChannelConfig[4], &MODULE_ADC);
    /* Change TMADC channel configuration */

    /* Select the channel ID and the respective result register */
    tmadcChannelConfig[4].id             = IfxAdc_TmadcChannel_4;          /* Channel ID                             */
    tmadcChannelConfig[4].moduleId       = IfxAdc_TmadcModule_0;           /* Select TMADC module                    */
    tmadcChannelConfig[4].samplingTimeNS = 100;                            /* Set sampling time period               */
    tmadcChannelConfig[4].mode           = IfxAdc_TmadcOpMode_oneShot;     /* Select operating mode - one shot       */
    tmadcChannelConfig[4].core           = IfxAdc_TmadcSarCore_0;          /* Select TMADC SAR core                  */

    tmadcChannelConfig[4].resultCfg.resultReg   = IfxAdc_TmadcResultReg_4; /* Configure result register              */
    tmadcChannelConfig[4].resultCfg.waitForRead = TRUE;                    /* Enable wait-for-read mode              */

    tmadcChannelConfig[4].trigger = &trigger;

    /* Set channel service request */
    tmacChannelServRequest[4].errorNode     = IfxAdc_TmadcServReq_none;    /* Configure Service request error node   */
    tmacChannelServRequest[4].boundaryNode  = IfxAdc_TmadcServReq_none;    /* Configure Service request boundary node*/
    tmacChannelServRequest[4].resultNode    = IfxAdc_TmadcServReq_0;       /* Configure Service request result node  */

    /* Assign configured channel service request to configuration */
    tmadcChannelConfig[4].channelSrvReq = &tmacChannelServRequest[4];

    /* Initialize the channel */
    IfxAdc_Tmadc_initChannel(&g_tmadcChannel[4], &tmadcChannelConfig[4]);
}
